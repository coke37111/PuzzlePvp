# 인게임 UI 개선 구현 계획

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Classic1의 인게임 UI 패턴 3가지(반사판 카운트, HP 바 그래디언트, 데미지 팝업)를 PuzzlePvP Phaser.js 클라이언트에 구현한다.

**Architecture:** 모두 클라이언트 사이드 변경. shared/server 수정 없음. `Constants.ts`에 상수 추가, `VisualEffects.ts`에 애니메이션 함수 추가, `GameScene.ts`에서 표시 및 이벤트 처리.

**Tech Stack:** TypeScript, Phaser.js 3, Vite (hot reload)

---

## 수정 대상 파일

- `packages/client/src/visual/Constants.ts` — 상수 추가
- `packages/client/src/visual/VisualEffects.ts` — 데미지 팝업 함수 추가, HP 바 색상 함수 추가
- `packages/client/src/scenes/GameScene.ts` — UI 표시 + 이벤트 처리

## 변경 없는 파일

- `packages/shared/` — 변경 없음 (서버 메시지 그대로 사용)
- `packages/server/` — 변경 없음

---

## Task 1: HP 바 그래디언트 색상

**목표:** 스폰포인트 HP 바 색상이 HP 비율에 따라 변한다.
- ratio ≥ 0.5: 초록(0x44cc44) ↔ 노랑(0xcccc44) 사이 선형 보간
- ratio < 0.5: 노랑(0xcccc44) ↔ 빨강(0xff2222) 사이 선형 보간

**Files:**
- Modify: `packages/client/src/visual/Constants.ts`
- Modify: `packages/client/src/visual/VisualEffects.ts`
- Modify: `packages/client/src/scenes/GameScene.ts`

### Step 1: Constants.ts에 HP 색상 상수 추가

`Constants.ts` 끝에 추가:

```typescript
// === HP 바 그래디언트 색상 ===
export const HP_COLOR_HIGH  = 0x44cc44;  // 초록 (100%)
export const HP_COLOR_MID   = 0xcccc44;  // 노랑 (50%)
export const HP_COLOR_LOW   = 0xff2222;  // 빨강 (0%)
```

### Step 2: VisualEffects.ts에 HP 색상 계산 함수 추가

`VisualEffects.ts`에 import 추가 및 함수 추가:

imports에 추가:
```typescript
import {
  // ...기존...
  HP_COLOR_HIGH, HP_COLOR_MID, HP_COLOR_LOW,
} from './Constants';
```

파일 끝에 함수 추가:
```typescript
/** HP 비율(0~1)에 따른 그래디언트 색상 반환 */
export function getHpColor(ratio: number): number {
  if (ratio >= 0.5) {
    // 초록 → 노랑 (ratio 1.0→0.5)
    const t = (ratio - 0.5) * 2;  // 1.0→0.0
    return lerpColor(HP_COLOR_MID, HP_COLOR_HIGH, t);
  } else {
    // 노랑 → 빨강 (ratio 0.5→0.0)
    const t = ratio * 2;  // 1.0→0.0
    return lerpColor(HP_COLOR_LOW, HP_COLOR_MID, t);
  }
}

function lerpColor(a: number, b: number, t: number): number {
  const ar = (a >> 16) & 0xff, ag = (a >> 8) & 0xff, ab = a & 0xff;
  const br = (b >> 16) & 0xff, bg = (b >> 8) & 0xff, bb = b & 0xff;
  const r = Math.round(ar + (br - ar) * t);
  const g = Math.round(ag + (bg - ag) * t);
  const bl = Math.round(ab + (bb - ab) * t);
  return (r << 16) | (g << 8) | bl;
}
```

### Step 3: GameScene.ts의 updateSpawnHp에서 HP 색상 업데이트

현재 코드:
```typescript
animHpBar(this, visual.hpBar, baseX, ratio, `hp_${spawnId}`, this.hpTweens);

// HP 감소 시 데미지 플래시
if (hp < oldHp) {
  animDamageFlash(this, visual.bg, PLAYER_COLORS_DARK[visual.ownerId], 0.4);
}
```

변경 후:
```typescript
const hpColor = getHpColor(ratio);
visual.hpBar.setFillStyle(hpColor);
animHpBar(this, visual.hpBar, baseX, ratio, `hp_${spawnId}`, this.hpTweens);

if (hp < oldHp) {
  animDamageFlash(this, visual.bg, PLAYER_COLORS_DARK[visual.ownerId], 0.4);
}
```

import에 `getHpColor` 추가:
```typescript
import {
  animBallSpawn,
  animBallEnd,
  animReflectorPlace,
  animHpBar,
  animDamageFlash,
  animSpawnDestroy,
  getHpColor,  // 추가
} from '../visual/VisualEffects';
```

### Step 4: 초기 스폰포인트 생성 시에도 HP 색상 적용

`createSpawnVisual`에서 hpBar 생성 부분:
```typescript
// 변경 전
const hpBar = this.add.rectangle(
  px, py - TILE_SIZE / 2 + HP_BAR_HEIGHT,
  TILE_SIZE - 4, HP_BAR_HEIGHT, PLAYER_COLORS[ownerId],
);
```

```typescript
// 변경 후 (maxHp 기준 초기 색상 = 100% = 초록)
const hpBar = this.add.rectangle(
  px, py - TILE_SIZE / 2 + HP_BAR_HEIGHT,
  TILE_SIZE - 4, HP_BAR_HEIGHT, getHpColor(1.0),
);
```

---

## Task 2: 데미지 팝업 (피격 시 숫자 표시)

**목표:** 스폰포인트가 피격될 때 "-1" 텍스트가 위로 날아가며 페이드 아웃.
- 지속시간: 1.0초
- 이동: y축 -50px
- 페이드: 0.3초 후 시작
- 색상: 흰색

**Files:**
- Modify: `packages/client/src/visual/Constants.ts`
- Modify: `packages/client/src/visual/VisualEffects.ts`
- Modify: `packages/client/src/scenes/GameScene.ts`

### Step 1: Constants.ts에 팝업 타이밍 상수 추가

```typescript
// === 데미지 팝업 ===
export const ANIM_DAMAGE_POPUP_DURATION = 1000;   // 전체 시간 (ms)
export const ANIM_DAMAGE_POPUP_MOVE_Y   = -50;    // 위로 이동 거리 (px)
export const ANIM_DAMAGE_POPUP_FADE_START = 300;  // 페이드 시작 지연 (ms)
```

### Step 2: VisualEffects.ts에 animDamagePopup 함수 추가

imports에 추가:
```typescript
import {
  // ...기존...
  ANIM_DAMAGE_POPUP_DURATION,
  ANIM_DAMAGE_POPUP_MOVE_Y,
  ANIM_DAMAGE_POPUP_FADE_START,
} from './Constants';
```

파일 끝에 추가:
```typescript
/** 데미지 팝업: "-N" 텍스트가 위로 날아가며 페이드 아웃 */
export function animDamagePopup(
  scene: Phaser.Scene,
  container: Phaser.GameObjects.Container,
  worldX: number,
  worldY: number,
  damage: number,
): void {
  const text = scene.add.text(worldX, worldY, `-${damage}`, {
    fontSize: '16px',
    color: '#ffffff',
    fontStyle: 'bold',
    stroke: '#000000',
    strokeThickness: 3,
  }).setOrigin(0.5, 1);
  container.add(text);

  scene.tweens.add({
    targets: text,
    y: worldY + ANIM_DAMAGE_POPUP_MOVE_Y,
    duration: ANIM_DAMAGE_POPUP_DURATION,
    ease: 'Quad.easeOut',
    onComplete: () => text.destroy(),
  });

  scene.time.delayedCall(ANIM_DAMAGE_POPUP_FADE_START, () => {
    scene.tweens.add({
      targets: text,
      alpha: 0,
      duration: ANIM_DAMAGE_POPUP_DURATION - ANIM_DAMAGE_POPUP_FADE_START,
      ease: 'Linear',
    });
  });
}
```

### Step 3: GameScene.ts에서 데미지 팝업 호출

`updateSpawnHp` 함수의 HP 감소 처리 부분에 팝업 추가:

```typescript
if (hp < oldHp) {
  animDamageFlash(this, visual.bg, PLAYER_COLORS_DARK[visual.ownerId], 0.4);

  // 데미지 팝업 추가
  const damage = oldHp - hp;
  const popupX = visual.x * TILE_SIZE + TILE_SIZE / 2;
  const popupY = visual.y * TILE_SIZE;  // 타일 상단
  animDamagePopup(this, this.tilesLayer, popupX, popupY, damage);
}
```

import에 `animDamagePopup` 추가.

---

## Task 3: 반사판 카운트 UI

**목표:** 화면 하단 반사판 버튼 위에 "◆ 3/5" 형식으로 남은 반사판 수 표시.
- 내 반사판 수는 클라이언트에서 reflectorVisuals를 카운트해 추적
- maxReflectors = 5 (CLAUDE.md 게임 밸런스 수치)
- 반사판 설치/제거 이벤트 후 UI 업데이트

**Files:**
- Modify: `packages/client/src/visual/Constants.ts`
- Modify: `packages/client/src/scenes/GameScene.ts`

### Step 1: Constants.ts에 상수 추가

```typescript
// === 게임 규칙 ===
export const MAX_REFLECTORS_PER_PLAYER = 5;
```

### Step 2: GameScene.ts에 반사판 카운트 텍스트 필드 추가

클래스 필드에 추가:
```typescript
private reflectorCountText: Phaser.GameObjects.Text | null = null;
```

### Step 3: setupUI()에 카운트 텍스트 생성

`setupUI()` 내에서 `this.add.text(width / 2, height - 70, 'Reflector', ...)` 부분을 수정:

```typescript
// 기존
this.add.text(width / 2, height - 70, 'Reflector', {
  fontSize: '13px',
  color: '#888899',
}).setOrigin(0.5);
```

```typescript
// 변경
this.add.text(width / 2, height - 72, 'Reflector', {
  fontSize: '11px',
  color: '#888899',
}).setOrigin(0.5);

this.reflectorCountText = this.add.text(
  width / 2, height - 57,
  `◆ ${MAX_REFLECTORS_PER_PLAYER}/${MAX_REFLECTORS_PER_PLAYER}`,
  {
    fontSize: '13px',
    color: '#aaaaff',
    fontStyle: 'bold',
  },
).setOrigin(0.5);
```

import에 `MAX_REFLECTORS_PER_PLAYER` 추가.

### Step 4: 반사판 카운트 업데이트 메서드 추가

```typescript
private updateReflectorCount(): void {
  if (!this.reflectorCountText) return;
  const myCount = [...this.reflectorVisuals.values()]
    .filter(v => v.playerId === this.myPlayerId).length;
  const remaining = MAX_REFLECTORS_PER_PLAYER - myCount;
  this.reflectorCountText.setText(`◆ ${remaining}/${MAX_REFLECTORS_PER_PLAYER}`);

  // 남은 수에 따라 색상 변경
  if (remaining === 0) {
    this.reflectorCountText.setColor('#ff4444');
  } else if (remaining <= 2) {
    this.reflectorCountText.setColor('#cccc44');
  } else {
    this.reflectorCountText.setColor('#aaaaff');
  }
}
```

### Step 5: 반사판 이벤트 핸들러에서 카운트 업데이트 호출

`onReflectorPlaced` 핸들러 끝에:
```typescript
this.socket.onReflectorPlaced = (msg: ReflectorPlacedMsg) => {
  this.drawReflector(msg.x, msg.y, msg.type, msg.playerId);
  animReflectorPlace(this, this.tilesLayer, msg.x, msg.y, PLAYER_COLORS[msg.playerId]);
  this.updateReflectorCount();  // 추가
};
```

`onReflectorRemoved` 핸들러 끝에:
```typescript
this.socket.onReflectorRemoved = (msg: ReflectorRemovedMsg) => {
  const key = `${msg.x},${msg.y}`;
  const visual = this.reflectorVisuals.get(key);
  if (visual) {
    visual.graphics.destroy();
    this.reflectorVisuals.delete(key);
  }
  this.updateReflectorCount();  // 추가
};
```

---

## 구현 순서 요약

1. Task 1 (HP 그래디언트) — Constants.ts → VisualEffects.ts → GameScene.ts
2. Task 2 (데미지 팝업) — Constants.ts → VisualEffects.ts → GameScene.ts
3. Task 3 (반사판 카운트) — Constants.ts → GameScene.ts

각 Task 완료 후 `npm run dev:client`로 확인.
shared 수정 없으므로 `npm run build:shared` 불필요.
